%%% vim:foldmethod=marker

% Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
%       Triangle      Tn=n(n+1)/2     1, 3, 6, 10, 15, ...
%       Pentagonal    Pn=n(3n−1)/2    1, 5, 12, 22, 35, ...
%       Hexagonal     Hn=n(2n−1)      1, 6, 15, 28, 45, ...
% It can be verified that T(285) = P(165) = H(143) = 40755.
% Find the next triangle number that is also pentagonal and hexagonal.

-module(problem0045).

-export([solve/1]).

-include_lib("eunit/include/eunit.hrl").

%%% API   {{{1

solve(N) ->
    solve({triangle(N), N}, {pentagonal(N), N}, {hexagonal(N), N}).

solve({Solution, Nt}, {Solution, Np}, {Solution, Nh}) ->
    io:format("T(~p) = P(~p) = H(~p) = ~p~n", [Nt, Np, Nh, Solution]);
solve(Triangle, Pentagonal, Hexagonal) ->
    solve(Triangle, Pentagonal, Hexagonal, lists:min([Triangle, Pentagonal, Hexagonal])).

solve({_Tn, Nt} = Min, Pentagonal, Hexagonal, Min) ->
    solve({triangle(Nt+1), Nt+1}, Pentagonal, Hexagonal);
solve(Triangle, {_Pn, Np} = Min, Hexagonal, Min) ->
    solve(Triangle, {pentagonal(Np+1), Np+1}, Hexagonal);
solve(Triangle, Pentagonal, {_Hn, Nh} = Min, Min) ->
    solve(Triangle, Pentagonal, {hexagonal(Nh+1), Nh+1}).

%%% Internal functions   {{{1
triangle(N) -> round(N*(N+1)/2).
pentagonal(N) -> round(N*(3*N-1)/2).
hexagonal(N) -> round(N*(2*N-1)).

%%% Unit Tests   {{{1
triangle_test_() ->
    [
      ?_assertEqual(1, triangle(1))
     ,?_assertEqual(3, triangle(2))
     ,?_assertEqual(6, triangle(3))
    ].

pentagonal_test_() ->
    [
      ?_assertEqual(1, pentagonal(1))
     ,?_assertEqual(5, pentagonal(2))
     ,?_assertEqual(12, pentagonal(3))
    ].

hexagonal_test_() ->
    [
      ?_assertEqual(1, hexagonal(1))
     ,?_assertEqual(6, hexagonal(2))
     ,?_assertEqual(15, hexagonal(3))
    ].

solve_test_() ->
    [
      ?_assertEqual(100, solve({100,12}, {100,4}, {100,6}))
    ].
