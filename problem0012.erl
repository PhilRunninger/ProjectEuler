% The sequence of triangle numbers is generated by adding the natural numbers. 
% So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
% The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
% 
% Let us list the factors of the first seven triangle numbers:
%  1: 1
%  3: 1,3
%  6: 1,2,3,6
% 10: 1,2,5,10
% 15: 1,3,5,15
% 21: 1,3,7,21
% 28: 1,2,4,7,14,28
% We can see that 28 is the first triangle number to have over five divisors.
% What is the value of the first triangle number to have over five hundred divisors?
-module(problem0012).
-export([solve/1, factors/1, triangle/1]).
-include_lib("eunit/include/eunit.hrl").

solve(Limit)        -> solve(Limit, 1, triangle(1), factors(triangle(1))).

solve(Limit, _N, TriN, Factors) when length(Factors) > Limit -> {TriN, Factors};
solve(Limit, N, _TriN, _Factors) -> solve(Limit, N+1, triangle(N+1), factors(triangle(N+1))).

triangle(TopNumber) -> triangle(TopNumber, 0).
triangle(0, Sum) -> Sum;
triangle(N, Sum) -> triangle(N-1, Sum+N).

factors(N) -> factors(N, 1, N, []).
factors(_N, F1, F2, Factors) when F1 > F2     -> lists:usort(Factors);
factors(N, F1, F2, Factors) when F1 * F2 == N -> factors(N, F1+1, round(N / (F1+1)), Factors ++ [F1, F2]);
factors(N, F1, _F2, Factors)                  -> factors(N, F1+1, round(N / (F1+1)), Factors).

triangle_test_() ->
    [
     ?_assertEqual(1, triangle(1)),
     ?_assertEqual(3, triangle(2)),
     ?_assertEqual(6, triangle(3))
    ].
factors_test_() ->
    [
     ?_assertEqual([1], factors(1)),
     ?_assertEqual([1,3], factors(3)),
     ?_assertEqual([1,2,3,6], factors(6)),
     ?_assertEqual([1,2,5,10], factors(10)),
     ?_assertEqual([1,3,5,15], factors(15)),
     ?_assertEqual([1,3,7,21], factors(21)),
     ?_assertEqual([1,2,4,7,14,28], factors(28))
    ].
solve_test_() ->
    [
     ?_assertEqual({6,[1,2,3,6]}, solve(3)),
     ?_assertEqual({28,[1,2,4,7,14,28]}, solve(5))
    ].
